#include "imports/stdlib.fc";

const op::stake = 0x7374616b65; ;; stake
const op::unstake = 0x756e7374616b65; ;; unstake


() load_data() impure inline {
    slice ds = get_data().begin_parse();
    storage::owner_address = ds~load_msg_addr();
    storage::jetton_wallet_address = ds~load_msg_addr();
    storage::percent_year = ds~load_uint(64);
    storage::lockup_period = ds~load_uint(64);
    storage::current_reward = ds~load_coins();
    storage::total_reward = ds~load_coins();
    ds.end_parse();
}

() save_data() impure inline {
    set_data(
        begin_cell()
            .store_slice(storage::owner_address)
            .store_slice(storage::jetton_wallet_address)
            .store_uint(storage::percent_year, 64)
            .store_uint(storage::lockup_period, 64)
            .store_coins(storage::current_reward)
            .store_coins(storage::total_reward)
            .end_cell()
    );
}


() calculate_jetton_address()


() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {
    if (in_msg_body.slice_empty?()) { ;; ignore empty messages
        return ();
    }
    slice cs = in_msg_full.begin_parse();
    int flags = cs~load_uint(4);

    if (flags & 1) { ;; ignore all bounced messages
        return ();
    }
    slice sender_address = cs~load_msg_addr();

    int op = in_msg_body~load_uint(32);

    load_data();

    if (op::stake == op) {
        throw_unless(100, equal_slices(sender_address, calculate_jetton_address()));
    }

    load_data();
}
